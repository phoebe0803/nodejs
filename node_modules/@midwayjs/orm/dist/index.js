"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useEntityModel = exports.Configuration = exports.EventSubscriberModel = exports.InjectEntityModel = exports.EntityView = exports.EntityModel = exports.ORM_MODEL_KEY = exports.EVENT_SUBSCRIBER_KEY = exports.ENTITY_MODEL_KEY = exports.CONNECTION_KEY = void 0;
const core_1 = require("@midwayjs/core");
const decorator_1 = require("@midwayjs/decorator");
const typeorm_1 = require("typeorm");
exports.CONNECTION_KEY = 'orm:getConnection';
exports.ENTITY_MODEL_KEY = 'entity_model_key';
exports.EVENT_SUBSCRIBER_KEY = 'event_subscriber_key';
exports.ORM_MODEL_KEY = '__orm_model_key__';
/**
 * Entity - typeorm
 * @param nameOrOptions string|EntityOptions
 * @param maybeOptions EntityOptions
 */
function EntityModel(nameOrOptions, maybeOptions) {
    const options = (typeof nameOrOptions === 'object'
        ? nameOrOptions
        : maybeOptions) || {};
    const name = typeof nameOrOptions === 'string' ? nameOrOptions : options.name;
    const connectionName = (options === null || options === void 0 ? void 0 : options.connectionName) || 'ALL';
    return function (target) {
        if (typeof target === 'function') {
            (0, core_1.saveModule)(exports.ENTITY_MODEL_KEY, target);
            (0, decorator_1.saveClassMetadata)(exports.ENTITY_MODEL_KEY, { connectionName }, target);
        }
        else {
            (0, core_1.saveModule)(exports.ENTITY_MODEL_KEY, target.constructor);
            (0, decorator_1.saveClassMetadata)(exports.ENTITY_MODEL_KEY, { connectionName }, target.constructor);
        }
        (0, typeorm_1.getMetadataArgsStorage)().tables.push({
            target: target,
            name: name,
            type: 'regular',
            orderBy: options.orderBy ? options.orderBy : undefined,
            engine: options.engine ? options.engine : undefined,
            database: options.database ? options.database : undefined,
            schema: options.schema ? options.schema : undefined,
            synchronize: options.synchronize,
            withoutRowid: options.withoutRowid,
        });
    };
}
exports.EntityModel = EntityModel;
/**
 * Entity - typeorm
 * @param nameOrOptions string|ViewEntityOptions
 * @param maybeOptions ViewEntityOptions
 */
function EntityView(nameOrOptions, maybeOptions) {
    const options = (typeof nameOrOptions === 'object'
        ? nameOrOptions
        : maybeOptions) || {};
    const name = typeof nameOrOptions === 'string' ? nameOrOptions : options.name;
    const connectionName = (options === null || options === void 0 ? void 0 : options.connectionName) || 'ALL';
    return function (target) {
        if (typeof target === 'function') {
            (0, core_1.saveModule)(exports.ENTITY_MODEL_KEY, target);
            (0, decorator_1.saveClassMetadata)(exports.ENTITY_MODEL_KEY, { connectionName }, target);
        }
        else {
            (0, core_1.saveModule)(exports.ENTITY_MODEL_KEY, target.constructor);
            (0, decorator_1.saveClassMetadata)(exports.ENTITY_MODEL_KEY, { connectionName }, target.constructor);
        }
        (0, typeorm_1.getMetadataArgsStorage)().tables.push({
            target: target,
            name: name,
            type: 'view',
            database: options.database ? options.database : undefined,
            schema: options.schema ? options.schema : undefined,
            expression: options.expression ? options.expression : undefined,
            materialized: options.materialized ? options.materialized : undefined,
            synchronize: options.synchronize,
        });
    };
}
exports.EntityView = EntityView;
function InjectEntityModel(modelKey, connectionName = 'default') {
    return (target, propertyKey) => {
        (0, core_1.attachClassMetadata)(exports.ORM_MODEL_KEY, {
            key: {
                modelKey,
                connectionName,
            },
            propertyName: propertyKey,
        }, target);
    };
}
exports.InjectEntityModel = InjectEntityModel;
/**
 * EventSubscriber - typeorm
 * implements EntitySubscriberInterface
 */
function EventSubscriberModel(options = {}) {
    return function (target) {
        (0, core_1.saveModule)(exports.EVENT_SUBSCRIBER_KEY, target);
        (0, decorator_1.saveClassMetadata)(exports.EVENT_SUBSCRIBER_KEY, options, target);
    };
}
exports.EventSubscriberModel = EventSubscriberModel;
var configuration_1 = require("./configuration");
Object.defineProperty(exports, "Configuration", { enumerable: true, get: function () { return configuration_1.OrmConfiguration; } });
__exportStar(require("./hook"), exports);
__exportStar(require("./repository"), exports);
/**
 * for hooks useEntityModel method
 * @param clz
 * @param instanceName
 */
function useEntityModel(clz, connectionName) {
    return (0, typeorm_1.getRepository)(clz, connectionName);
}
exports.useEntityModel = useEntityModel;
//# sourceMappingURL=index.js.map