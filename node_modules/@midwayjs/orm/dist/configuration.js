"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrmConfiguration = void 0;
const decorator_1 = require("@midwayjs/decorator");
const path_1 = require("path");
const typeorm_1 = require("typeorm");
const _1 = require(".");
const hook_1 = require("./hook");
let OrmConfiguration = class OrmConfiguration {
    constructor() {
        this.connectionNames = [];
    }
    async init() {
        this.app
            .getApplicationContext()
            .registerDataHandler(_1.ORM_MODEL_KEY, (key) => {
            // return getConnection(key.connectionName).getRepository(key.modelKey);
            return (0, typeorm_1.getRepository)(key.modelKey, key.connectionName);
        });
    }
    async onReady(container) {
        const entities = (0, decorator_1.listModule)(_1.ENTITY_MODEL_KEY);
        const eventSubs = (0, decorator_1.listModule)(_1.EVENT_SUBSCRIBER_KEY);
        const connectionNameMap = { ALL: [] };
        for (const entity of entities) {
            const _connectionName = (0, decorator_1.getClassMetadata)(_1.ENTITY_MODEL_KEY, entity).connectionName;
            if (!connectionNameMap[_connectionName]) {
                connectionNameMap[_connectionName] = [];
            }
            connectionNameMap[_connectionName].push(entity);
        }
        const opts = this.formatConfig();
        for (const connectionOption of opts) {
            const name = connectionOption.name || 'default';
            const connectionEntities = [
                ...connectionNameMap['ALL'],
                ...(connectionNameMap[name] || []),
            ];
            connectionOption.entities = connectionOption.entities
                ? connectionOption.entities
                : connectionEntities || [];
            connectionOption.subscribers = eventSubs || [];
            this.connectionNames.push(name);
            let isConnected = false;
            try {
                const conn = (0, typeorm_1.getConnection)(name);
                if (conn.isConnected) {
                    isConnected = true;
                }
            }
            catch (_a) {
                /* ignore */
            }
            if (!isConnected) {
                const rtOpt = await this.beforeCreate(container, connectionOption);
                const con = await (0, typeorm_1.createConnection)(rtOpt);
                await this.afterCreate(container, rtOpt, con);
            }
        }
        container.registerObject(_1.CONNECTION_KEY, instanceName => {
            if (!instanceName) {
                instanceName = 'default';
            }
            return (0, typeorm_1.getConnection)(instanceName);
        });
        // get event model
        const eventModules = (0, decorator_1.listModule)(_1.EVENT_SUBSCRIBER_KEY);
        for (const eventModule of eventModules) {
            const eventModuleMetadata = (0, decorator_1.getClassMetadata)(_1.EVENT_SUBSCRIBER_KEY, eventModule);
            const module = await container.getAsync(eventModule);
            (0, typeorm_1.getConnection)(eventModuleMetadata.connectionName || 'default').subscribers.push(module);
        }
    }
    async onStop(container) {
        await Promise.all(Object.values(this.connectionNames).map(async (connectionName) => {
            const conn = (0, typeorm_1.getConnection)(connectionName);
            await this.beforeClose(container, conn, connectionName);
            if (conn.isConnected) {
                await conn.close();
            }
            await this.afterClose(container, conn);
        }));
        this.connectionNames.length = 0;
    }
    formatConfig() {
        const originConfig = this.ormConfig;
        if (originConfig === null || originConfig === void 0 ? void 0 : originConfig.type) {
            originConfig.name = 'default';
            return [originConfig];
        }
        else {
            const newArr = [];
            for (const [key, value] of Object.entries(originConfig)) {
                value.name = key;
                newArr.push(value);
            }
            return newArr;
        }
    }
    /**
     * 创建 connection 之前
     * @param container
     * @param opts
     */
    async beforeCreate(container, opts) {
        let rt = opts;
        const clzzs = (0, decorator_1.listModule)(hook_1.ORM_HOOK_KEY);
        for (const clzz of clzzs) {
            const inst = await container.getAsync(clzz);
            if (inst.beforeCreate && typeof inst.beforeCreate === 'function') {
                rt = await inst.beforeCreate(rt);
            }
        }
        return rt;
    }
    /**
     * 创建 connection 之后
     * @param container
     * @param opts
     * @param con
     */
    async afterCreate(container, opts, con) {
        let rtCon = con;
        const clzzs = (0, decorator_1.listModule)(hook_1.ORM_HOOK_KEY);
        for (const clzz of clzzs) {
            const inst = await container.getAsync(clzz);
            if (inst.afterCreate && typeof inst.afterCreate === 'function') {
                rtCon = await inst.afterCreate(con, opts);
            }
        }
        return rtCon;
    }
    /**
     * 关闭连接之前
     * @param container
     * @param con
     * @param connectionName
     */
    async beforeClose(container, con, connectionName) {
        let rt = con;
        const clzzs = (0, decorator_1.listModule)(hook_1.ORM_HOOK_KEY);
        for (const clzz of clzzs) {
            const inst = await container.getAsync(clzz);
            if (inst.beforeClose && typeof inst.beforeClose === 'function') {
                rt = await inst.beforeClose(rt, connectionName);
            }
        }
        return rt;
    }
    /**
     * 关闭连接之后
     * @param container
     * @param con
     */
    async afterClose(container, con) {
        let rt = con;
        const clzzs = (0, decorator_1.listModule)(hook_1.ORM_HOOK_KEY);
        for (const clzz of clzzs) {
            const inst = await container.getAsync(clzz);
            if (inst.afterClose && typeof inst.afterClose === 'function') {
                rt = await inst.afterClose(rt);
            }
        }
        return rt;
    }
};
__decorate([
    (0, decorator_1.Config)('orm'),
    __metadata("design:type", Object)
], OrmConfiguration.prototype, "ormConfig", void 0);
__decorate([
    (0, decorator_1.App)(),
    __metadata("design:type", Object)
], OrmConfiguration.prototype, "app", void 0);
__decorate([
    (0, decorator_1.Init)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], OrmConfiguration.prototype, "init", null);
OrmConfiguration = __decorate([
    (0, decorator_1.Configuration)({
        importConfigs: [(0, path_1.join)(__dirname, './config')],
        namespace: 'orm',
    })
], OrmConfiguration);
exports.OrmConfiguration = OrmConfiguration;
//# sourceMappingURL=configuration.js.map